/*
** Copyright 2007-2024, RTE (https://www.rte-france.com)
** See AUTHORS.txt
** SPDX-License-Identifier: MPL-2.0
** This file is part of Antares-Simulator,
** Adequacy and Performance assessment for interconnected energy networks.
**
** Antares_Simulator is free software: you can redistribute it and/or modify
** it under the terms of the Mozilla Public Licence 2.0 as published by
** the Mozilla Foundation, either version 2 of the License, or
** (at your option) any later version.
**
** XNothingX in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
** Mozilla Public Licence 2.0 for more details.
**
** You should have received a copy of the Mozilla Public Licence 2.0
** along with Antares_Simulator. If not, see <https://opensource.org/license/mpl-2-0/>.
*/
#ifndef __ANTARES_LIBS_STUDY_PARAMETERS_H__
#define __ANTARES_LIBS_STUDY_PARAMETERS_H__

#include <cassert>
#include <cstdlib>
#include <vector>

#include <yuni/yuni.h>
#include <yuni/core/string.h>

#include <antares/date/date.h>
#include <antares/inifile/inifile.h>
#include <antares/optimization-options/options.h>
#include <antares/study/UnfeasibleProblemBehavior.hpp>
#include <antares/writer/result_format.h>
#include "antares/antares/antares.h"
#include "antares/study/fwd.h"

#include "parameters/adq-patch-params.h"
#include "variable-print-info.h"
#include "version.h"

namespace Antares::Data
{
/*!
** \brief General data for a study
**
** Those data are located into the file `generalData.ini`
*/
class Parameters final
{
public:
    //! \name Simulation mode
    //@{
    //! Get if the simulation is in economy mode
    bool economy() const;
    //! Get if the simulation is in adequacy mode
    bool adequacy() const;
    //@}

    /*!
    ** \brief Reset the playlist (played years and associated years)
    */
    void resetPlaylist(uint nbOfYears);

    /*!
    ** \brief Load data from a file
    **
    ** This routine ensures that the structure is properly initialized with
    ** default values, whatever is the result.
    ** If the filename is empty, or it does not exists, or the file can not
    ** be opened, the routine will return 0.
    **
    ** \param filename The file to load
    ** \param version Current study version
    ** \return True if the settings have been loaded, false if at least one error has occured
    */
    bool loadFromFile(const AnyString& filename, const StudyVersion& version);

    /*!
    ** \brief Prepare all settings for a simulation
    **
    ** The solver must be able to rely on all variables for performance reasons.
    ** The first case scenario can be the user who might not have disabled all settings,
    ** like the `refresh`, that can have a non-zero value even if the ts-generator
    ** is disabled.
    ** Another case would be the directives given by the command line.
    **
    ** \note This method is automatically called from `loadFromFile()` if the
    **  flag options.usedByTheSolver is set.
    ** \see loadFromFile()
    */
    void prepareForSimulation(const StudyLoadOptions& options);

    /*!
    ** \brief Save data to an ini file
    **
    ** \param filename The target filename
    ** \return True if the file has been successfully saved, false otherwise
    */
    bool saveToFile(const AnyString& filename) const;

    /*!
    ** \brief Get if a time-series must be generated by the preprocessor
    **
    ** \param mask The time-serie to test
    ** \return True if the time-series must be generated by the preprocessor, false otherwise
    */
    bool isTSGeneratedByPrepro(const TimeSeriesType ts) const;

    /*!
    ** \brief Reset to default all values in a structure for general data
    */
    void reset();
    /*!
    ** \brief Reset to default all seeds
    */
    void resetSeeds();
    /*!
    ** \brief Reset to default all threshold values in adequacy patch
    */
    void resetThresholdsAdqPatch();
    /*!
    ** \brief Reset to default all adequacy patch values
    */
    void resetAdqPatchParameters();

    /*!
    ** \brief Handle priority between command-line option and configuration file
    */
    void handleOptimizationOptions(const StudyLoadOptions& options);

    /*!
    ** \brief Try to detect then fix any bad value
    */
    void fixBadValues();

    void validateOptions(const StudyLoadOptions&);

    /*!
    ** \brief Try to detect then fix refresh intervals
    */
    void fixRefreshIntervals();

    /*!
    ** \brief Try to detect then fix TS generation/refresh parameters
    *         for NTC
    */
    void fixGenRefreshForNTC();

    /*!
    ** \brief Get the amount of memory used by the general data
    */
    uint64_t memoryUsage() const;

    /*!
    ** \brief Reset MC year weight to 1 for all years
    */
    void resetYearsWeigth();

    /*!
    ** \brief Get MC years weight dependending on playlist configuration
    **
    ** \return std::vector<float> with weight for each MC year
    */
    std::vector<float> getYearsWeight() const;

    /*!
    ** \brief Get MC years weight sum dependending on playlist configuration
    **
    ** \return weigth sum (nbYears if playlist disabled). If playlist is enabled and years weight
    *sum is null, 1.0 is returned to avoid division by 0
    */
    float getYearsWeightSum() const;

    /*!
    ** \brief Define weight for a MC year
    **
    ** \param year MC year index
    ** \param weight MC year weight
    */
    void setYearWeight(uint year, float weight);

    // Do we create files in the input folder ?
    bool haveToImport(int tsKind) const;

    //! Save the internal settings into an INI file
    void saveToINI(IniFile& ini) const;

public:
    //! \name Mode
    //@{
    //! Mode of the study (adequacy, economy...)
    SimulationMode mode;
    //@}

    //! \name Horizon
    //@{
    //! Horizon year, not used by the solver
    Yuni::String horizon;
    //@}

    //! \name Calendar
    //@{
    //! Number of years to study
    uint nbYears;
    //! Simulation days interval
    Date::DayInterval simulationDays;
    //! Day of the 1st january
    DayOfTheWeek dayOfThe1stJanuary;
    //! First day in the week
    DayOfTheWeek firstWeekday;
    //! The first month of the simulation year
    MonthName firstMonthInYear;
    //! Leap year
    bool leapYear;
    //@}

    //! \name Additional
    //@{
    //! Export results each year
    bool yearByYear;
    //! Derated
    bool derated;
    //! Custom scenario
    bool useCustomScenario;
    //! Custom playlist (each year will be manually selected by the user)
    bool userPlaylist;
    //! Flag to perform the calculations or not from the solver
    std::vector<bool> yearsFilter;

    //! Custom variable selection (each variable will be manually selected for print by the user)
    bool thematicTrimming;
    //! List of all output variables print info
    mutable AllVariablesPrintInfo variablesPrintInfo;

    //! The number of years that will be really performed
    // Computed automatically from the number of MC years and the playlist
    uint effectiveNbYears;
    //! Enable/Disable filtering by files :
    //!		for an area or a link, print (or not) a file associated to :
    //!		- a time division (hourly results, daily results, weekly results, ...),
    //!		- a kind of result (year by year result or a synthesis result).
    bool geographicTrimming;
    //@}

    //! \name TimeSeries
    //@{
    //! Nb of timeSeries : Load
    uint nbTimeSeriesLoad;
    //! Nb of timeSeries : Hydro
    uint nbTimeSeriesHydro;
    //! Nb of timeSeries : Wind
    uint nbTimeSeriesWind;
    //! Nb of timeSeries : Thermal
    uint nbTimeSeriesThermal;
    //! Nb of timeSeries : Solar
    uint nbTimeSeriesSolar;
    //@}

    //! \name Time-series refresh
    //@{
    /*!
    ** \brief Time series to refresh on-line
    **
    ** This value is a mask bits for timeSeries
    ** \see TimeSeries
    */
    uint timeSeriesToRefresh;

    //! Refresh interval (in years) for timeSeries : Load
    uint refreshIntervalLoad;
    //! Refresh interval (in years) for timeSeries : Hydro
    uint refreshIntervalHydro;
    //! Refresh interval (in years) for timeSeries : Wind
    uint refreshIntervalWind;
    //! Refresh interval (in years) for timeSeries : Thermal
    uint refreshIntervalThermal;
    //! Refresh interval (in years) for timeSeries : Solar
    uint refreshIntervalSolar;
    //@}

    //! \name Archives
    //@{
    /*!
    ** \brief TimeSeries to archive
    **
    ** Only generated timeSeries will be archived.
    ** This value is a mask bits for timeSeries.
    ** \see TimeSeries
    */
    uint timeSeriesToArchive;
    //@}

    //! \name Pre-Processor
    //@{
    /*!
    ** \brief TimeSeries to generate
    **
    ** This value is a mask bits for timeSeries.
    ** \see TimeSeries
    */
    uint timeSeriesToGenerate;
    //@}

    //! \name Import Time-Series to HardDrive
    //@{
    /*!
    ** \brief TimeSeries to Import
    **
    ** This value is a mask bits for timeSeries.
    ** All generated timeseries will be re-written into the input
    ** \see TimeSeries
    */
    uint exportTimeSeriesInInput;
    //@}

    //! \name Correlated draws
    //@{
    /*!
    ** \brief TimeSeries where the draws are correlated
    **
    ** This value is a mask bits for timeSeries.
    ** \see TimeSeries
    ** This is the historical correlation mode
    */
    uint intraModal;

    /*!
    ** \brief Inter-modal
    */
    uint interModal;
    //@}

    //! \name Timeseries numbers
    //@{
    //! Store the sampled timeseries numbers
    bool storeTimeseriesNumbers;
    //@}

    /*!
    ** \brief Read-only mode
    **
    ** This value can only be set by the property `read-only` in the
    ** generaldata.ini. The default value is `false`.
    */
    bool readonly;

    //! Write the simulation synthesis into the output
    bool synthesis;

    //! \name Optimization
    //@{
    //! Spillage bound
    bool spillageBound;

    //! Improve units startup
    bool improveUnitsStartup;

    //! Accuracy on correlation
    uint timeSeriesAccuracyOnCorrelation;

    //@}

    //! \name Optimization preferences
    //@{
    struct IncludeOptions
    {
        //! Include binding constraints
        bool constraints;
        //! Hurdle costs
        bool hurdleCosts;

        struct Reserve
        {
            //! Day ahead reserve
            bool dayAhead;
            //! Strategic reserve
            bool strategic;
            //! Spinning reserve
            bool spinning;
            //! Primary reserve
            bool primary;

        } reserve;

        struct Thermal
        {
            // Thermal cluster min stable power
            bool minStablePower;

            //! Thermal cluster Min U/D Time
            bool minUPTime;
        } thermal;

        //! Flag to export mps files
        mpsExportStatus exportMPS;

        //! a flag to export structure needed for Antares XPansion
        bool exportStructure;

        //! Enum to define unfeasible problem behavior \see UnfeasibleProblemBehavior
        UnfeasibleProblemBehavior unfeasibleProblemBehavior;

    } include;

    // Shedding
    struct
    {
        //! Shedding policy
        SheddingPolicy policy;
    } shedding;

    struct
    {
        //! Power fluctuations
        PowerFluctuations fluctuations;
    } power;

    struct UCMode
    {
        //! Unit Commitment Mode
        UnitCommitmentMode ucMode;

        //! Some variables rely on dual values & marginal costs
        void addExcludedVariables(std::vector<std::string>&) const;
    };

    UCMode unitCommitment;

    struct
    {
        //! Number of Cores Mode
        NumberOfCoresMode ncMode;
    } nbCores;

    struct RenewableGeneration
    {
        //! Renewable generation mode
        RenewableGenerationModelling rgModelling;
        void addExcludedVariables(std::vector<std::string>&) const;
        RenewableGenerationModelling operator()() const;
        void toAggregated();
        void toClusters();
        bool isAggregated() const;
        bool isClusters() const;
    };

    RenewableGeneration renewableGeneration;

    struct
    {
        //! Hydro heuristic policy
        HydroHeuristicPolicy hhPolicy;
    } hydroHeuristicPolicy;

    struct
    {
        //! Hydro Pricing Mode
        HydroPricingMode hpMode;
    } hydroPricing;

    //! Transmission capacities
    GlobalTransmissionCapacities transmissionCapacities;
    //! Simplex optimization range (day/week)
    SimplexOptimization simplexOptimizationRange;
    //@}

    AdequacyPatch::AdqPatchParams adqPatchParams;

    //! \name Scenariio Builder - Rules
    //@{
    //! The current active rules for building scenarios (useful if building mode == custom)
    RulesScenarioName activeRulesScenario;
    //@}

    //! \name Output
    //@{
    //! No output
    // This variable is not stored within the study but only used by the solver
    bool noOutput = false;
    //@}

    bool hydroDebug;

    //! \name Seeds
    //@{
    //! Seeds
    uint seed[seedMax];
    //@}

    // Format of results. Currently, only single files or zip archive are supported
    ResultFormat resultFormat = legacyFilesDirectories;

    // Naming constraints and variables in problems
    bool namedProblems;

    // All options related to optimization
    Antares::Solver::Optimization::OptimizationOptions optOptions;

private:
    //! Load data from an INI file
    bool loadFromINI(const IniFile& ini, const StudyVersion& version);

    void resetPlayedYears(uint nbOfYears);

    //! MC year weight for MC synthesis
    std::vector<float> yearsWeight;

}; // class Parameters

/*!
** \brief Convert a simulation mode (enum) into a human readable C-String
*/
const char* SimulationModeToCString(SimulationMode mode);

/*!
** \brief Convert a C-String (lowercase) into a simulation mode if possible
**
** \param[out] mode The simulation mode. It will remain untouched if the conversion failed
** \param Text An arbitrary Text (case insensitive)
** \return True if the conversion succeeded, false otherwise
*/
bool StringToSimulationMode(SimulationMode& mode, Yuni::CString<20, false> text);

} // namespace Antares::Data

#endif // __ANTARES_LIBS_STUDY_PARAMETERS_H__
