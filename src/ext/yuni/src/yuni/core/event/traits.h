/*
** This file is part of libyuni, a cross-platform C++ framework (http://libyuni.org).
**
** This Source Code Form is subject to the terms of the Mozilla Public License
** v.2.0. If a copy of the MPL was not distributed with this file, You can
** obtain one at http://mozilla.org/MPL/2.0/.
**
** github: https://github.com/libyuni/libyuni/
** gitlab: https://gitlab.com/libyuni/libyuni/ (mirror)
*/
#pragma once

/*!
** \internal This file is automatically generated by 'traits.h.generator.hpp'.
** Please make any modifications you wish to this script instead of
** this file, as they will otherwise be lost at the next generation.
*/

#include "../slist/slist.h"
#include "../atomic/bool.h"



namespace Yuni
{
namespace Private
{
namespace EventImpl
{

	template<int N, class BindT> class WithNArguments;


	template<typename T>
	class EmptyPredicate final
	{
	public:
		typedef void ResultType;
	public:
		inline void operator () (T) {}
		static void result() {}
	};


	template<class BindT>
	class PredicateRemoveObject final
	{
	public:
		PredicateRemoveObject(const void* object) :
			pObject(object)
		{}

		bool operator == (const BindT& rhs) const
		{
			return  (pObject == reinterpret_cast<const void*>(rhs.object()));
		}
	private:
		const void* pObject;
	};


	template<class BindT>
	class PredicateRemoveObserverBase final
	{
	public:
		PredicateRemoveObserverBase(IEvent* event, const IEventObserverBase* object) :
			pEvent(event), pObject(object)
		{}

		bool operator == (const BindT& rhs) const
		{
			if (pObject == rhs.observerBaseObject())
			{
				pObject->boundEventDecrementReference(pEvent);
				return true;
			}
			return false;
		}
	private:
		IEvent* pEvent;
		const IEventObserverBase* pObject;
	};


	template<class BindT>
	class PredicateRemoveWithoutChecks final
	{
	public:
		PredicateRemoveWithoutChecks(const IEventObserverBase* object) :
			pObject(object)
		{}

		inline bool operator == (const BindT& rhs) const
		{
			return (rhs.isDescendantOf(pObject));
		}
	private:
		const IEventObserverBase* pObject;
	};



	struct FoldTypeVoid {};
	template<class T> struct FoldType { typedef T value_type; };
	template<> struct FoldType<void> { typedef FoldTypeVoid value_type; };





	template<class BindT>
	class WithNArguments<0, BindT> : public Policy::ObjectLevelLockable<WithNArguments<0,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<0,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke() const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke();
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke());
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke() const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke());
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke());
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () () const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke();
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<1, BindT> : public Policy::ObjectLevelLockable<WithNArguments<1,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<1,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<2, BindT> : public Policy::ObjectLevelLockable<WithNArguments<2,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<2,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<3, BindT> : public Policy::ObjectLevelLockable<WithNArguments<3,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<3,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<4, BindT> : public Policy::ObjectLevelLockable<WithNArguments<4,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<4,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<5, BindT> : public Policy::ObjectLevelLockable<WithNArguments<5,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<5,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<6, BindT> : public Policy::ObjectLevelLockable<WithNArguments<6,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<6,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<7, BindT> : public Policy::ObjectLevelLockable<WithNArguments<7,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<7,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<8, BindT> : public Policy::ObjectLevelLockable<WithNArguments<8,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<8,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;
		//! Type of the argument 7
		typedef typename BindType::template Argument<7>::Type A7;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<9, BindT> : public Policy::ObjectLevelLockable<WithNArguments<9,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<9,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;
		//! Type of the argument 7
		typedef typename BindType::template Argument<7>::Type A7;
		//! Type of the argument 8
		typedef typename BindType::template Argument<8>::Type A8;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<10, BindT> : public Policy::ObjectLevelLockable<WithNArguments<10,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<10,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;
		//! Type of the argument 7
		typedef typename BindType::template Argument<7>::Type A7;
		//! Type of the argument 8
		typedef typename BindType::template Argument<8>::Type A8;
		//! Type of the argument 9
		typedef typename BindType::template Argument<9>::Type A9;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<11, BindT> : public Policy::ObjectLevelLockable<WithNArguments<11,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<11,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;
		//! Type of the argument 7
		typedef typename BindType::template Argument<7>::Type A7;
		//! Type of the argument 8
		typedef typename BindType::template Argument<8>::Type A8;
		//! Type of the argument 9
		typedef typename BindType::template Argument<9>::Type A9;
		//! Type of the argument 10
		typedef typename BindType::template Argument<10>::Type A10;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<12, BindT> : public Policy::ObjectLevelLockable<WithNArguments<12,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<12,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;
		//! Type of the argument 7
		typedef typename BindType::template Argument<7>::Type A7;
		//! Type of the argument 8
		typedef typename BindType::template Argument<8>::Type A8;
		//! Type of the argument 9
		typedef typename BindType::template Argument<9>::Type A9;
		//! Type of the argument 10
		typedef typename BindType::template Argument<10>::Type A10;
		//! Type of the argument 11
		typedef typename BindType::template Argument<11>::Type A11;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<13, BindT> : public Policy::ObjectLevelLockable<WithNArguments<13,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<13,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;
		//! Type of the argument 7
		typedef typename BindType::template Argument<7>::Type A7;
		//! Type of the argument 8
		typedef typename BindType::template Argument<8>::Type A8;
		//! Type of the argument 9
		typedef typename BindType::template Argument<9>::Type A9;
		//! Type of the argument 10
		typedef typename BindType::template Argument<10>::Type A10;
		//! Type of the argument 11
		typedef typename BindType::template Argument<11>::Type A11;
		//! Type of the argument 12
		typedef typename BindType::template Argument<12>::Type A12;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<14, BindT> : public Policy::ObjectLevelLockable<WithNArguments<14,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<14,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;
		//! Type of the argument 7
		typedef typename BindType::template Argument<7>::Type A7;
		//! Type of the argument 8
		typedef typename BindType::template Argument<8>::Type A8;
		//! Type of the argument 9
		typedef typename BindType::template Argument<9>::Type A9;
		//! Type of the argument 10
		typedef typename BindType::template Argument<10>::Type A10;
		//! Type of the argument 11
		typedef typename BindType::template Argument<11>::Type A11;
		//! Type of the argument 12
		typedef typename BindType::template Argument<12>::Type A12;
		//! Type of the argument 13
		typedef typename BindType::template Argument<13>::Type A13;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<15, BindT> : public Policy::ObjectLevelLockable<WithNArguments<15,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<15,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;
		//! Type of the argument 7
		typedef typename BindType::template Argument<7>::Type A7;
		//! Type of the argument 8
		typedef typename BindType::template Argument<8>::Type A8;
		//! Type of the argument 9
		typedef typename BindType::template Argument<9>::Type A9;
		//! Type of the argument 10
		typedef typename BindType::template Argument<10>::Type A10;
		//! Type of the argument 11
		typedef typename BindType::template Argument<11>::Type A11;
		//! Type of the argument 12
		typedef typename BindType::template Argument<12>::Type A12;
		//! Type of the argument 13
		typedef typename BindType::template Argument<13>::Type A13;
		//! Type of the argument 14
		typedef typename BindType::template Argument<14>::Type A14;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments



	template<class BindT>
	class WithNArguments<16, BindT> : public Policy::ObjectLevelLockable<WithNArguments<16,BindT> >
	{
	public:
		//! The Threading Policy
		typedef Policy::ObjectLevelLockable<WithNArguments<16,BindT> > ThreadingPolicy;
		//! Bind
		typedef BindT BindType;
		//! The Return type
		typedef typename BindType::ReturnType R;
		//! Type of the argument 0
		typedef typename BindType::template Argument<0>::Type A0;
		//! Type of the argument 1
		typedef typename BindType::template Argument<1>::Type A1;
		//! Type of the argument 2
		typedef typename BindType::template Argument<2>::Type A2;
		//! Type of the argument 3
		typedef typename BindType::template Argument<3>::Type A3;
		//! Type of the argument 4
		typedef typename BindType::template Argument<4>::Type A4;
		//! Type of the argument 5
		typedef typename BindType::template Argument<5>::Type A5;
		//! Type of the argument 6
		typedef typename BindType::template Argument<6>::Type A6;
		//! Type of the argument 7
		typedef typename BindType::template Argument<7>::Type A7;
		//! Type of the argument 8
		typedef typename BindType::template Argument<8>::Type A8;
		//! Type of the argument 9
		typedef typename BindType::template Argument<9>::Type A9;
		//! Type of the argument 10
		typedef typename BindType::template Argument<10>::Type A10;
		//! Type of the argument 11
		typedef typename BindType::template Argument<11>::Type A11;
		//! Type of the argument 12
		typedef typename BindType::template Argument<12>::Type A12;
		//! Type of the argument 13
		typedef typename BindType::template Argument<13>::Type A13;
		//! Type of the argument 14
		typedef typename BindType::template Argument<14>::Type A14;
		//! Type of the argument 15
		typedef typename BindType::template Argument<15>::Type A15;


	public:
		//! \name Constructors
		//@{
		//! Default constructor
		WithNArguments() :
			pEmpty(true)
		{}
		//! Copy constructor
		WithNArguments(const WithNArguments& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			pEmpty = rhs.pEmpty;
			pBindList = rhs.pBindList;
		}
		//@}

		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		*/
		void invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
			}
		}

		template<class CallbackT>
		R fold(typename FoldType<R>::value_type initval, const CallbackT& accumulator, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
		{
			if (not pEmpty)
			{
				typename FoldType<R>::value_type value = initval;
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					accumulator(value, (*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15));
				return value;
			}
			return initval;
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
		{
			PredicateT<R> predicate;
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15));
			}
			return predicate.result();
		}


		template<template<class> class PredicateT>
		typename PredicateT<R>::ResultType invoke(PredicateT<R>& predicate, A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					predicate((*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15));
			}
			return predicate.result();
		}

		template<class EventT> void assign(EventT& rhs)
		{
			typename ThreadingPolicy::MutexLocker locker(*this);
			typename ThreadingPolicy::MutexLocker lockerRHS(rhs);
			pBindList = rhs.pBindList;
			pEmpty = pBindList.empty();
		}

		/*!
		** \brief Invoke the delegate
		*/
		void operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
		{
			if (not pEmpty)
			{
				typename ThreadingPolicy::MutexLocker locker(*this);
				const typename BindList::const_iterator end = pBindList.end();
				for (typename BindList::const_iterator i = pBindList.begin(); i != end; ++i)
					(*i).invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
			}
		}
		//@}


	protected:
		//! Binding list (type)
		typedef LinkedList<BindType> BindList;
		//! A flag to know if the event is empty or not
		// This value must only set when the mutex is locked
		volatile bool pEmpty;
		//! Binding list
		BindList pBindList;
		// friend !
		template<class P> friend class Event;

	}; // class WithNArguments







} // namespace EventImpl
} // namespace Private
} // namespace Yuni
