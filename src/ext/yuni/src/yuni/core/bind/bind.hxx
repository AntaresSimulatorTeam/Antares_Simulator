/*
** YUNI's default license is the GNU Lesser Public License (LGPL), with some
** exclusions (see below). This basically means that you can get the full source
** code for nothing, so long as you adhere to a few rules.
**
** Under the LGPL you may use YUNI for any purpose you wish, and modify it if you
** require, as long as you:
**
** Pass on the (modified) YUNI source code with your software, with original
** copyrights intact :
**  * If you distribute electronically, the source can be a separate download
**    (either from your own site if you modified YUNI, or to the official YUNI
**    website if you used an unmodified version) â€“ just include a link in your
**    documentation
**  * If you distribute physical media, the YUNI source that you used to build
**    your application should be included on that media
** Make it clear where you have customised it.
**
** In addition to the LGPL license text, the following exceptions / clarifications
** to the LGPL conditions apply to YUNI:
**
**  * Making modifications to YUNI configuration files, build scripts and
**    configuration headers such as yuni/platform.h in order to create a
**    customised build setup of YUNI with the otherwise unmodified source code,
**    does not constitute a derived work
**  * Building against YUNI headers which have inlined code does not constitute a
**    derived work
**  * Code which subclasses YUNI classes outside of the YUNI libraries does not
**    form a derived work
**  * Statically linking the YUNI libraries into a user application does not make
**    the user application a derived work.
**  * Using source code obsfucation on the YUNI source code when distributing it
**    is not permitted.
** As per the terms of the LGPL, a "derived work" is one for which you have to
** distribute source code for, so when the clauses above define something as not
** a derived work, it means you don't have to distribute source code for it.
** However, the original YUNI source code with all modifications must always be
** made available.
*/
#pragma once
#include "bind.h"




/*!
** \internal This file is automatically generated by 'bind.hxx.generator.hpp'.
** Please make any modifications you wish to this script instead of
** this file, as they will otherwise be lost at the next generation.
*/




namespace Yuni
{




	// Constructor
	template<class R>
	inline Bind<R (), void>::Bind()
		: pHolder(new Private::BindImpl::None<R ()>()) // unbind
	{}

	// Constructor
	template<class R>
	inline Bind<R (), void>::Bind(const Bind<R (), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R>
	inline Bind<R (), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R>
	inline Bind<R (), void>
	Bind<R (), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R>
	template<class C>
	inline Bind<R (), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R ()>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R>
	inline Bind<R (), void>::Bind(R (*pointer)())
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R>
	template<class C>
	inline Bind<R (), void>::Bind(C* c, R (C::*member)())
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R>
	inline void Bind<R (), void>::bind(R (*pointer)())
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R ()>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R>
	inline void Bind<R (), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R ()>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R>
	template<class U>
	inline void Bind<R (), void>::bind(R (*pointer)(U),
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R>
	template<class C>
	inline void Bind<R (), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R ()>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R>
	template<class C>
	void Bind<R (), void>::bind(C* c, R (C::*member)())
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C>
	void Bind<R (), void>::bind(const C* c, R (C::*member)() const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)())
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R()>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)() const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R()>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U),
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U) const,
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	template<class U, class C>
	void Bind<R (), void>::bind(C* c, R (C::*member)(U),
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	template<class U, class C>
	void Bind<R (), void>::bind(const C* c, R (C::*member)(U) const,
		typename Bind<R (), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	inline void Bind<R (), void>::bind(const Bind<R (), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R (), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R ()>(); // unbind
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R (), void>::clear()
	{
		unbind();
	}


	template<class R>
	inline bool Bind<R (), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke();
	}




	template<class R>
	inline R Bind<R (), void>::invoke() const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline bool Bind<R (), void>::operator ! () const
	{
		return empty();
	}


	template<class R>
	inline R Bind<R (), void>::operator () () const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline R Bind<R (), void>::emptyCallback()
	{
		return R();
	}

	template<class R>
	inline const void* Bind<R (), void>::object() const
	{
		return pHolder->object();
	}

	template<class R>
	inline const IEventObserverBase* Bind<R (), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R>
	inline bool Bind<R (), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R>
	inline bool Bind<R (), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R>
	inline void Bind<R (), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R>
	inline void Bind<R (), void>::emptyCallbackReturnsVoid()
	{
		/* Do nothing */
	}






	template<class R>
	inline Bind<R (), void>& Bind<R (), void>::operator = (R (*pointer)())
	{
		bind(pointer);
		return *this;
	}


	template<class R>
	inline Bind<R (), void>& Bind<R (), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R>
	inline Bind<R (), void>& Bind<R (), void>::operator = (const Bind<R (), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R>
	template<class C>
	inline Bind<R (), void>& Bind<R (), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R ()>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R>
	inline Bind<R (), void>& Bind<R (), void>::operator = (Bind<R (), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R>
	inline bool Bind<R (), void>::operator == (R (*pointer)()) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R>
	template<class U>
	inline bool Bind<R (), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R>
	inline Bind<R (*)(), void>::Bind()
		: pHolder(new Private::BindImpl::None<R ()>()) // unbind
	{}

	// Constructor
	template<class R>
	inline Bind<R (*)(), void>::Bind(const Bind<R (*)(), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R>
	inline Bind<R (*)(), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R>
	inline Bind<R (*)(), void>
	Bind<R (*)(), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R>
	template<class C>
	inline Bind<R (*)(), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R ()>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R>
	inline Bind<R (*)(), void>::Bind(R (*pointer)())
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R>
	template<class C>
	inline Bind<R (*)(), void>::Bind(C* c, R (C::*member)())
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R>
	inline void Bind<R (*)(), void>::bind(R (*pointer)())
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R ()>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R>
	inline void Bind<R (*)(), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R ()>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R>
	template<class U>
	inline void Bind<R (*)(), void>::bind(R (*pointer)(U),
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R>
	template<class C>
	inline void Bind<R (*)(), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R ()>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R>
	template<class C>
	void Bind<R (*)(), void>::bind(C* c, R (C::*member)())
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C>
	void Bind<R (*)(), void>::bind(const C* c, R (C::*member)() const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)())
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R()>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)() const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R()>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U),
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U) const,
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	template<class U, class C>
	void Bind<R (*)(), void>::bind(C* c, R (C::*member)(U),
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	template<class U, class C>
	void Bind<R (*)(), void>::bind(const C* c, R (C::*member)(U) const,
		typename Bind<R (*)(), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R>
	inline void Bind<R (*)(), void>::bind(const Bind<R (*)(), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R (*)(), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R ()>(); // unbind
	}


	// Bind: unbind
	template<class R>
	inline void Bind<R (*)(), void>::clear()
	{
		unbind();
	}


	template<class R>
	inline bool Bind<R (*)(), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke();
	}




	template<class R>
	inline R Bind<R (*)(), void>::invoke() const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline bool Bind<R (*)(), void>::operator ! () const
	{
		return empty();
	}


	template<class R>
	inline R Bind<R (*)(), void>::operator () () const
	{
		return pHolder->invoke();
	}


	template<class R>
	inline R Bind<R (*)(), void>::emptyCallback()
	{
		return R();
	}

	template<class R>
	inline const void* Bind<R (*)(), void>::object() const
	{
		return pHolder->object();
	}

	template<class R>
	inline const IEventObserverBase* Bind<R (*)(), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R>
	inline bool Bind<R (*)(), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R>
	inline bool Bind<R (*)(), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R>
	inline void Bind<R (*)(), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R>
	inline void Bind<R (*)(), void>::emptyCallbackReturnsVoid()
	{
		/* Do nothing */
	}






	template<class R>
	inline Bind<R (*)(), void>& Bind<R (*)(), void>::operator = (R (*pointer)())
	{
		bind(pointer);
		return *this;
	}


	template<class R>
	inline Bind<R (*)(), void>& Bind<R (*)(), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R>
	inline Bind<R (*)(), void>& Bind<R (*)(), void>::operator = (const Bind<R (*)(), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R>
	template<class C>
	inline Bind<R (*)(), void>& Bind<R (*)(), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R ()>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R>
	inline Bind<R (*)(), void>& Bind<R (*)(), void>::operator = (Bind<R (*)(), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R>
	inline bool Bind<R (*)(), void>::operator == (R (*pointer)()) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R>
	template<class U>
	inline bool Bind<R (*)(), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R ()>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>::Bind(const Bind<R (ClassT::*)(), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>
	Bind<R (ClassT::*)(), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R>
	template<class C>
	inline Bind<R (ClassT::*)(), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R ()>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>::Bind(R (*pointer)())
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R>
	template<class C>
	inline Bind<R (ClassT::*)(), ClassT>::Bind(C* c, R (C::*member)())
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::bind(R (*pointer)())
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R ()>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R ()>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R>
	template<class U>
	inline void Bind<R (ClassT::*)(), ClassT>::bind(R (*pointer)(U),
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R>
	template<class C>
	inline void Bind<R (ClassT::*)(), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R ()>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R>
	template<class C>
	void Bind<R (ClassT::*)(), ClassT>::bind(C* c, R (C::*member)())
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class C>
	void Bind<R (ClassT::*)(), ClassT>::bind(const C* c, R (C::*member)() const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			pHolder = new Private::BindImpl::BoundWithMember<C, R()>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)())
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R()>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)() const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)();
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R()>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U),
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U) const,
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R>
	template<class U, class C>
	void Bind<R (ClassT::*)(), ClassT>::bind(C* c, R (C::*member)(U),
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R>
	template<class U, class C>
	void Bind<R (ClassT::*)(), ClassT>::bind(const C* c, R (C::*member)(U) const,
		typename Bind<R (ClassT::*)(), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::bind(const Bind<R (ClassT::*)(), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R ()>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R>
	inline bool Bind<R (ClassT::*)(), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke();
	}




	template<class ClassT, class R>
	inline R Bind<R (ClassT::*)(), ClassT>::invoke() const
	{
		return pHolder->invoke();
	}


	template<class ClassT, class R>
	inline bool Bind<R (ClassT::*)(), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R>
	inline R Bind<R (ClassT::*)(), ClassT>::operator () () const
	{
		return pHolder->invoke();
	}


	template<class ClassT, class R>
	inline R Bind<R (ClassT::*)(), ClassT>::emptyCallback()
	{
		return R();
	}

	template<class ClassT, class R>
	inline const void* Bind<R (ClassT::*)(), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R>
	inline const IEventObserverBase* Bind<R (ClassT::*)(), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R>
	inline bool Bind<R (ClassT::*)(), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R>
	inline bool Bind<R (ClassT::*)(), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R>
	inline void Bind<R (ClassT::*)(), ClassT>::emptyCallbackReturnsVoid()
	{
		/* Do nothing */
	}






	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>& Bind<R (ClassT::*)(), ClassT>::operator = (R (*pointer)())
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>& Bind<R (ClassT::*)(), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>& Bind<R (ClassT::*)(), ClassT>::operator = (const Bind<R (ClassT::*)(), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R>
	template<class C>
	inline Bind<R (ClassT::*)(), ClassT>& Bind<R (ClassT::*)(), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R ()>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R>
	inline Bind<R (ClassT::*)(), ClassT>& Bind<R (ClassT::*)(), ClassT>::operator = (Bind<R (ClassT::*)(), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R>
	inline bool Bind<R (ClassT::*)(), ClassT>::operator == (R (*pointer)()) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R>
	template<class U>
	inline bool Bind<R (ClassT::*)(), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0>
	inline Bind<R (A0), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0)>()) // unbind
	{}

	// Constructor
	template<class R, class A0>
	inline Bind<R (A0), void>::Bind(const Bind<R (A0), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0>
	inline Bind<R (A0), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0>
	inline Bind<R (A0), void>
	Bind<R (A0), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0>
	template<class C>
	inline Bind<R (A0), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0>
	inline Bind<R (A0), void>::Bind(R (*pointer)(A0))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0>
	template<class C>
	inline Bind<R (A0), void>::Bind(C* c, R (C::*member)(A0))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0>
	inline void Bind<R (A0), void>::bind(R (*pointer)(A0))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0>
	inline void Bind<R (A0), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0>
	template<class U>
	inline void Bind<R (A0), void>::bind(R (*pointer)(A0, U),
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0>
	template<class C>
	inline void Bind<R (A0), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0>
	template<class C>
	void Bind<R (A0), void>::bind(C* c, R (C::*member)(A0))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C>
	void Bind<R (A0), void>::bind(const C* c, R (C::*member)(A0) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U),
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U) const,
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (A0), void>::bind(C* c, R (C::*member)(A0, U),
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (A0), void>::bind(const C* c, R (C::*member)(A0, U) const,
		typename Bind<R (A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	inline void Bind<R (A0), void>::bind(const Bind<R (A0), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (A0), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (A0), void>::clear()
	{
		unbind();
	}


	template<class R, class A0>
	inline bool Bind<R (A0), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0));
	}




	template<class R, class A0>
	inline R Bind<R (A0), void>::invoke(A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline bool Bind<R (A0), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0>
	inline R Bind<R (A0), void>::operator () (A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline R Bind<R (A0), void>::emptyCallback(A0)
	{
		return R();
	}

	template<class R, class A0>
	inline const void* Bind<R (A0), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0>
	inline const IEventObserverBase* Bind<R (A0), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0>
	inline bool Bind<R (A0), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0>
	inline bool Bind<R (A0), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0>
	inline void Bind<R (A0), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0>
	inline void Bind<R (A0), void>::emptyCallbackReturnsVoid(A0)
	{
		/* Do nothing */
	}






	template<class R, class A0>
	inline Bind<R (A0), void>& Bind<R (A0), void>::operator = (R (*pointer)(A0))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (A0), void>& Bind<R (A0), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (A0), void>& Bind<R (A0), void>::operator = (const Bind<R (A0), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0>
	template<class C>
	inline Bind<R (A0), void>& Bind<R (A0), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0>
	inline Bind<R (A0), void>& Bind<R (A0), void>::operator = (Bind<R (A0), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0>
	inline bool Bind<R (A0), void>::operator == (R (*pointer)(A0)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0>
	template<class U>
	inline bool Bind<R (A0), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0>
	inline Bind<R (*)(A0), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0)>()) // unbind
	{}

	// Constructor
	template<class R, class A0>
	inline Bind<R (*)(A0), void>::Bind(const Bind<R (*)(A0), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0>
	inline Bind<R (*)(A0), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0>
	inline Bind<R (*)(A0), void>
	Bind<R (*)(A0), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0>
	template<class C>
	inline Bind<R (*)(A0), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0>
	inline Bind<R (*)(A0), void>::Bind(R (*pointer)(A0))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0>
	template<class C>
	inline Bind<R (*)(A0), void>::Bind(C* c, R (C::*member)(A0))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::bind(R (*pointer)(A0))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0>
	template<class U>
	inline void Bind<R (*)(A0), void>::bind(R (*pointer)(A0, U),
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0>
	template<class C>
	inline void Bind<R (*)(A0), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0>
	template<class C>
	void Bind<R (*)(A0), void>::bind(C* c, R (C::*member)(A0))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C>
	void Bind<R (*)(A0), void>::bind(const C* c, R (C::*member)(A0) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U),
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U) const,
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (*)(A0), void>::bind(C* c, R (C::*member)(A0, U),
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	template<class U, class C>
	void Bind<R (*)(A0), void>::bind(const C* c, R (C::*member)(A0, U) const,
		typename Bind<R (*)(A0), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::bind(const Bind<R (*)(A0), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::clear()
	{
		unbind();
	}


	template<class R, class A0>
	inline bool Bind<R (*)(A0), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0));
	}




	template<class R, class A0>
	inline R Bind<R (*)(A0), void>::invoke(A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline bool Bind<R (*)(A0), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0>
	inline R Bind<R (*)(A0), void>::operator () (A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class R, class A0>
	inline R Bind<R (*)(A0), void>::emptyCallback(A0)
	{
		return R();
	}

	template<class R, class A0>
	inline const void* Bind<R (*)(A0), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0>
	inline const IEventObserverBase* Bind<R (*)(A0), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0>
	inline bool Bind<R (*)(A0), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0>
	inline bool Bind<R (*)(A0), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0>
	inline void Bind<R (*)(A0), void>::emptyCallbackReturnsVoid(A0)
	{
		/* Do nothing */
	}






	template<class R, class A0>
	inline Bind<R (*)(A0), void>& Bind<R (*)(A0), void>::operator = (R (*pointer)(A0))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (*)(A0), void>& Bind<R (*)(A0), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0>
	inline Bind<R (*)(A0), void>& Bind<R (*)(A0), void>::operator = (const Bind<R (*)(A0), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0>
	template<class C>
	inline Bind<R (*)(A0), void>& Bind<R (*)(A0), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0>
	inline Bind<R (*)(A0), void>& Bind<R (*)(A0), void>::operator = (Bind<R (*)(A0), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0>
	inline bool Bind<R (*)(A0), void>::operator == (R (*pointer)(A0)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0>
	template<class U>
	inline bool Bind<R (*)(A0), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>::Bind(const Bind<R (ClassT::*)(A0), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>
	Bind<R (ClassT::*)(A0), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0>
	template<class C>
	inline Bind<R (ClassT::*)(A0), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>::Bind(R (*pointer)(A0))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0>
	template<class C>
	inline Bind<R (ClassT::*)(A0), ClassT>::Bind(C* c, R (C::*member)(A0))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::bind(R (*pointer)(A0))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0>
	template<class U>
	inline void Bind<R (ClassT::*)(A0), ClassT>::bind(R (*pointer)(A0, U),
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0>
	template<class C>
	inline void Bind<R (ClassT::*)(A0), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0>
	template<class C>
	void Bind<R (ClassT::*)(A0), ClassT>::bind(C* c, R (C::*member)(A0))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class C>
	void Bind<R (ClassT::*)(A0), ClassT>::bind(const C* c, R (C::*member)(A0) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U),
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U) const,
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0), ClassT>::bind(C* c, R (C::*member)(A0, U),
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0), ClassT>::bind(const C* c, R (C::*member)(A0, U) const,
		typename Bind<R (ClassT::*)(A0), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::bind(const Bind<R (ClassT::*)(A0), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0));
	}




	template<class ClassT, class R, class A0>
	inline R Bind<R (ClassT::*)(A0), ClassT>::invoke(A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class ClassT, class R, class A0>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0>
	inline R Bind<R (ClassT::*)(A0), ClassT>::operator () (A0 a0) const
	{
		return pHolder->invoke(a0);
	}


	template<class ClassT, class R, class A0>
	inline R Bind<R (ClassT::*)(A0), ClassT>::emptyCallback(A0)
	{
		return R();
	}

	template<class ClassT, class R, class A0>
	inline const void* Bind<R (ClassT::*)(A0), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0>
	inline void Bind<R (ClassT::*)(A0), ClassT>::emptyCallbackReturnsVoid(A0)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>& Bind<R (ClassT::*)(A0), ClassT>::operator = (R (*pointer)(A0))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>& Bind<R (ClassT::*)(A0), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>& Bind<R (ClassT::*)(A0), ClassT>::operator = (const Bind<R (ClassT::*)(A0), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0>
	template<class C>
	inline Bind<R (ClassT::*)(A0), ClassT>& Bind<R (ClassT::*)(A0), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0>
	inline Bind<R (ClassT::*)(A0), ClassT>& Bind<R (ClassT::*)(A0), ClassT>::operator = (Bind<R (ClassT::*)(A0), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::operator == (R (*pointer)(A0)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>::Bind(const Bind<R (A0, A1), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>
	Bind<R (A0, A1), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1>
	template<class C>
	inline Bind<R (A0, A1), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>::Bind(R (*pointer)(A0, A1))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1>
	template<class C>
	inline Bind<R (A0, A1), void>::Bind(C* c, R (C::*member)(A0, A1))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::bind(R (*pointer)(A0, A1))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1>
	template<class U>
	inline void Bind<R (A0, A1), void>::bind(R (*pointer)(A0, A1, U),
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1>
	template<class C>
	inline void Bind<R (A0, A1), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (A0, A1), void>::bind(C* c, R (C::*member)(A0, A1))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (A0, A1), void>::bind(const C* c, R (C::*member)(A0, A1) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U),
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (A0, A1), void>::bind(C* c, R (C::*member)(A0, A1, U),
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (A0, A1), void>::bind(const C* c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::bind(const Bind<R (A0, A1), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1>
	inline bool Bind<R (A0, A1), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1));
	}




	template<class R, class A0, class A1>
	inline R Bind<R (A0, A1), void>::invoke(A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline bool Bind<R (A0, A1), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1>
	inline R Bind<R (A0, A1), void>::operator () (A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline R Bind<R (A0, A1), void>::emptyCallback(A0, A1)
	{
		return R();
	}

	template<class R, class A0, class A1>
	inline const void* Bind<R (A0, A1), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1>
	inline const IEventObserverBase* Bind<R (A0, A1), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1>
	inline bool Bind<R (A0, A1), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1>
	inline bool Bind<R (A0, A1), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1>
	inline void Bind<R (A0, A1), void>::emptyCallbackReturnsVoid(A0, A1)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>& Bind<R (A0, A1), void>::operator = (R (*pointer)(A0, A1))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>& Bind<R (A0, A1), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>& Bind<R (A0, A1), void>::operator = (const Bind<R (A0, A1), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1>
	template<class C>
	inline Bind<R (A0, A1), void>& Bind<R (A0, A1), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1>
	inline Bind<R (A0, A1), void>& Bind<R (A0, A1), void>::operator = (Bind<R (A0, A1), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1>
	inline bool Bind<R (A0, A1), void>::operator == (R (*pointer)(A0, A1)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1>
	template<class U>
	inline bool Bind<R (A0, A1), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>::Bind(const Bind<R (*)(A0, A1), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>
	Bind<R (*)(A0, A1), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1>
	template<class C>
	inline Bind<R (*)(A0, A1), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>::Bind(R (*pointer)(A0, A1))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1>
	template<class C>
	inline Bind<R (*)(A0, A1), void>::Bind(C* c, R (C::*member)(A0, A1))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::bind(R (*pointer)(A0, A1))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1>
	template<class U>
	inline void Bind<R (*)(A0, A1), void>::bind(R (*pointer)(A0, A1, U),
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1>
	template<class C>
	inline void Bind<R (*)(A0, A1), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (*)(A0, A1), void>::bind(C* c, R (C::*member)(A0, A1))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C>
	void Bind<R (*)(A0, A1), void>::bind(const C* c, R (C::*member)(A0, A1) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U),
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (*)(A0, A1), void>::bind(C* c, R (C::*member)(A0, A1, U),
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (*)(A0, A1), void>::bind(const C* c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (*)(A0, A1), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::bind(const Bind<R (*)(A0, A1), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1>
	inline bool Bind<R (*)(A0, A1), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1));
	}




	template<class R, class A0, class A1>
	inline R Bind<R (*)(A0, A1), void>::invoke(A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline bool Bind<R (*)(A0, A1), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1>
	inline R Bind<R (*)(A0, A1), void>::operator () (A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class R, class A0, class A1>
	inline R Bind<R (*)(A0, A1), void>::emptyCallback(A0, A1)
	{
		return R();
	}

	template<class R, class A0, class A1>
	inline const void* Bind<R (*)(A0, A1), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1>
	inline const IEventObserverBase* Bind<R (*)(A0, A1), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1>
	inline bool Bind<R (*)(A0, A1), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1>
	inline bool Bind<R (*)(A0, A1), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1>
	inline void Bind<R (*)(A0, A1), void>::emptyCallbackReturnsVoid(A0, A1)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>& Bind<R (*)(A0, A1), void>::operator = (R (*pointer)(A0, A1))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>& Bind<R (*)(A0, A1), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>& Bind<R (*)(A0, A1), void>::operator = (const Bind<R (*)(A0, A1), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1>
	template<class C>
	inline Bind<R (*)(A0, A1), void>& Bind<R (*)(A0, A1), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1>
	inline Bind<R (*)(A0, A1), void>& Bind<R (*)(A0, A1), void>::operator = (Bind<R (*)(A0, A1), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1>
	inline bool Bind<R (*)(A0, A1), void>::operator == (R (*pointer)(A0, A1)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1>
	template<class U>
	inline bool Bind<R (*)(A0, A1), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>
	Bind<R (ClassT::*)(A0, A1), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::Bind(R (*pointer)(A0, A1))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>::Bind(C* c, R (C::*member)(A0, A1))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(R (*pointer)(A0, A1))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(R (*pointer)(A0, A1, U),
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(C* c, R (C::*member)(A0, A1))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const C* c, R (C::*member)(A0, A1) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U),
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(C* c, R (C::*member)(A0, A1, U),
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const C* c, R (C::*member)(A0, A1, U) const,
		typename Bind<R (ClassT::*)(A0, A1), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1));
	}




	template<class ClassT, class R, class A0, class A1>
	inline R Bind<R (ClassT::*)(A0, A1), ClassT>::invoke(A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class ClassT, class R, class A0, class A1>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1>
	inline R Bind<R (ClassT::*)(A0, A1), ClassT>::operator () (A0 a0, A1 a1) const
	{
		return pHolder->invoke(a0, a1);
	}


	template<class ClassT, class R, class A0, class A1>
	inline R Bind<R (ClassT::*)(A0, A1), ClassT>::emptyCallback(A0, A1)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1>
	inline const void* Bind<R (ClassT::*)(A0, A1), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1>
	inline void Bind<R (ClassT::*)(A0, A1), ClassT>::emptyCallbackReturnsVoid(A0, A1)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>& Bind<R (ClassT::*)(A0, A1), ClassT>::operator = (R (*pointer)(A0, A1))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>& Bind<R (ClassT::*)(A0, A1), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>& Bind<R (ClassT::*)(A0, A1), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>& Bind<R (ClassT::*)(A0, A1), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1>
	inline Bind<R (ClassT::*)(A0, A1), ClassT>& Bind<R (ClassT::*)(A0, A1), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::operator == (R (*pointer)(A0, A1)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>::Bind(const Bind<R (A0, A1, A2), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>
	Bind<R (A0, A1, A2), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2>
	template<class C>
	inline Bind<R (A0, A1, A2), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>::Bind(R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2>
	template<class C>
	inline Bind<R (A0, A1, A2), void>::Bind(C* c, R (C::*member)(A0, A1, A2))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::bind(R (*pointer)(A0, A1, A2))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2>
	template<class U>
	inline void Bind<R (A0, A1, A2), void>::bind(R (*pointer)(A0, A1, A2, U),
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2>
	template<class C>
	inline void Bind<R (A0, A1, A2), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (A0, A1, A2), void>::bind(C* c, R (C::*member)(A0, A1, A2))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (A0, A1, A2), void>::bind(const C* c, R (C::*member)(A0, A1, A2) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (A0, A1, A2), void>::bind(C* c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (A0, A1, A2), void>::bind(const C* c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::bind(const Bind<R (A0, A1, A2), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (A0, A1, A2), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2));
	}




	template<class R, class A0, class A1, class A2>
	inline R Bind<R (A0, A1, A2), void>::invoke(A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (A0, A1, A2), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (A0, A1, A2), void>::operator () (A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (A0, A1, A2), void>::emptyCallback(A0, A1, A2)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2>
	inline const void* Bind<R (A0, A1, A2), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2>
	inline const IEventObserverBase* Bind<R (A0, A1, A2), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (A0, A1, A2), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (A0, A1, A2), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2>
	inline void Bind<R (A0, A1, A2), void>::emptyCallbackReturnsVoid(A0, A1, A2)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>& Bind<R (A0, A1, A2), void>::operator = (R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>& Bind<R (A0, A1, A2), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>& Bind<R (A0, A1, A2), void>::operator = (const Bind<R (A0, A1, A2), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2>
	template<class C>
	inline Bind<R (A0, A1, A2), void>& Bind<R (A0, A1, A2), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2>
	inline Bind<R (A0, A1, A2), void>& Bind<R (A0, A1, A2), void>::operator = (Bind<R (A0, A1, A2), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (A0, A1, A2), void>::operator == (R (*pointer)(A0, A1, A2)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2>
	template<class U>
	inline bool Bind<R (A0, A1, A2), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>::Bind(const Bind<R (*)(A0, A1, A2), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>
	Bind<R (*)(A0, A1, A2), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2>
	template<class C>
	inline Bind<R (*)(A0, A1, A2), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>::Bind(R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2>
	template<class C>
	inline Bind<R (*)(A0, A1, A2), void>::Bind(C* c, R (C::*member)(A0, A1, A2))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::bind(R (*pointer)(A0, A1, A2))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2), void>::bind(R (*pointer)(A0, A1, A2, U),
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (*)(A0, A1, A2), void>::bind(C* c, R (C::*member)(A0, A1, A2))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (*)(A0, A1, A2), void>::bind(const C* c, R (C::*member)(A0, A1, A2) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2), void>::bind(C* c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2), void>::bind(const C* c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (*)(A0, A1, A2), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::bind(const Bind<R (*)(A0, A1, A2), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (*)(A0, A1, A2), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2));
	}




	template<class R, class A0, class A1, class A2>
	inline R Bind<R (*)(A0, A1, A2), void>::invoke(A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (*)(A0, A1, A2), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (*)(A0, A1, A2), void>::operator () (A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class R, class A0, class A1, class A2>
	inline R Bind<R (*)(A0, A1, A2), void>::emptyCallback(A0, A1, A2)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2>
	inline const void* Bind<R (*)(A0, A1, A2), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (*)(A0, A1, A2), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (*)(A0, A1, A2), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2>
	inline void Bind<R (*)(A0, A1, A2), void>::emptyCallbackReturnsVoid(A0, A1, A2)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>& Bind<R (*)(A0, A1, A2), void>::operator = (R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>& Bind<R (*)(A0, A1, A2), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>& Bind<R (*)(A0, A1, A2), void>::operator = (const Bind<R (*)(A0, A1, A2), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2>
	template<class C>
	inline Bind<R (*)(A0, A1, A2), void>& Bind<R (*)(A0, A1, A2), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2>
	inline Bind<R (*)(A0, A1, A2), void>& Bind<R (*)(A0, A1, A2), void>::operator = (Bind<R (*)(A0, A1, A2), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2>
	inline bool Bind<R (*)(A0, A1, A2), void>::operator == (R (*pointer)(A0, A1, A2)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::Bind(R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(R (*pointer)(A0, A1, A2))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(R (*pointer)(A0, A1, A2, U),
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, U),
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2));
	}




	template<class ClassT, class R, class A0, class A1, class A2>
	inline R Bind<R (ClassT::*)(A0, A1, A2), ClassT>::invoke(A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline R Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator () (A0 a0, A1 a1, A2 a2) const
	{
		return pHolder->invoke(a0, a1, a2);
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline R Bind<R (ClassT::*)(A0, A1, A2), ClassT>::emptyCallback(A0, A1, A2)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2>
	inline void Bind<R (ClassT::*)(A0, A1, A2), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>& Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator = (R (*pointer)(A0, A1, A2))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>& Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>& Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>& Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2>
	inline Bind<R (ClassT::*)(A0, A1, A2), ClassT>& Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator == (R (*pointer)(A0, A1, A2)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>::Bind(const Bind<R (A0, A1, A2, A3), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>
	Bind<R (A0, A1, A2, A3), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline Bind<R (A0, A1, A2, A3), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>::Bind(R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline Bind<R (A0, A1, A2, A3), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::bind(R (*pointer)(A0, A1, A2, A3))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3), void>::bind(R (*pointer)(A0, A1, A2, A3, U),
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (A0, A1, A2, A3), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (A0, A1, A2, A3), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::bind(const Bind<R (A0, A1, A2, A3), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (A0, A1, A2, A3), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3));
	}




	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (A0, A1, A2, A3), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (A0, A1, A2, A3), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (A0, A1, A2, A3), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (A0, A1, A2, A3), void>::emptyCallback(A0, A1, A2, A3)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline const void* Bind<R (A0, A1, A2, A3), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (A0, A1, A2, A3), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (A0, A1, A2, A3), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (A0, A1, A2, A3), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>& Bind<R (A0, A1, A2, A3), void>::operator = (R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>& Bind<R (A0, A1, A2, A3), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>& Bind<R (A0, A1, A2, A3), void>::operator = (const Bind<R (A0, A1, A2, A3), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline Bind<R (A0, A1, A2, A3), void>& Bind<R (A0, A1, A2, A3), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (A0, A1, A2, A3), void>& Bind<R (A0, A1, A2, A3), void>::operator = (Bind<R (A0, A1, A2, A3), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (A0, A1, A2, A3), void>::operator == (R (*pointer)(A0, A1, A2, A3)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>::Bind(const Bind<R (*)(A0, A1, A2, A3), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>
	Bind<R (*)(A0, A1, A2, A3), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>::Bind(R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::bind(R (*pointer)(A0, A1, A2, A3))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::bind(R (*pointer)(A0, A1, A2, A3, U),
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (*)(A0, A1, A2, A3), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::bind(const Bind<R (*)(A0, A1, A2, A3), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3));
	}




	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (*)(A0, A1, A2, A3), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (*)(A0, A1, A2, A3), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (*)(A0, A1, A2, A3), void>::emptyCallback(A0, A1, A2, A3)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline const void* Bind<R (*)(A0, A1, A2, A3), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (*)(A0, A1, A2, A3), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>& Bind<R (*)(A0, A1, A2, A3), void>::operator = (R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>& Bind<R (*)(A0, A1, A2, A3), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>& Bind<R (*)(A0, A1, A2, A3), void>::operator = (const Bind<R (*)(A0, A1, A2, A3), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3), void>& Bind<R (*)(A0, A1, A2, A3), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3>
	inline Bind<R (*)(A0, A1, A2, A3), void>& Bind<R (*)(A0, A1, A2, A3), void>::operator = (Bind<R (*)(A0, A1, A2, A3), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::operator == (R (*pointer)(A0, A1, A2, A3)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(R (*pointer)(A0, A1, A2, A3))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3) const
	{
		return pHolder->invoke(a0, a1, a2, a3);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::emptyCallback(A0, A1, A2, A3)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>::Bind(const Bind<R (A0, A1, A2, A3, A4), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>
	Bind<R (A0, A1, A2, A3, A4), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, U),
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::bind(const Bind<R (A0, A1, A2, A3, A4), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (A0, A1, A2, A3, A4), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (A0, A1, A2, A3, A4), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (A0, A1, A2, A3, A4), void>::emptyCallback(A0, A1, A2, A3, A4)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline const void* Bind<R (A0, A1, A2, A3, A4), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (A0, A1, A2, A3, A4), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>& Bind<R (A0, A1, A2, A3, A4), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>& Bind<R (A0, A1, A2, A3, A4), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>& Bind<R (A0, A1, A2, A3, A4), void>::operator = (const Bind<R (A0, A1, A2, A3, A4), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4), void>& Bind<R (A0, A1, A2, A3, A4), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (A0, A1, A2, A3, A4), void>& Bind<R (A0, A1, A2, A3, A4), void>::operator = (Bind<R (A0, A1, A2, A3, A4), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>
	Bind<R (*)(A0, A1, A2, A3, A4), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (*)(A0, A1, A2, A3, A4), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (*)(A0, A1, A2, A3, A4), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (*)(A0, A1, A2, A3, A4), void>::emptyCallback(A0, A1, A2, A3, A4)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (*)(A0, A1, A2, A3, A4), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>& Bind<R (*)(A0, A1, A2, A3, A4), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>& Bind<R (*)(A0, A1, A2, A3, A4), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>& Bind<R (*)(A0, A1, A2, A3, A4), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>& Bind<R (*)(A0, A1, A2, A3, A4), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (*)(A0, A1, A2, A3, A4), void>& Bind<R (*)(A0, A1, A2, A3, A4), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::emptyCallback(A0, A1, A2, A3, A4)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>
	Bind<R (A0, A1, A2, A3, A4, A5), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (A0, A1, A2, A3, A4, A5), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (A0, A1, A2, A3, A4, A5), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (A0, A1, A2, A3, A4, A5), void>::emptyCallback(A0, A1, A2, A3, A4, A5)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (A0, A1, A2, A3, A4, A5), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>& Bind<R (A0, A1, A2, A3, A4, A5), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>& Bind<R (A0, A1, A2, A3, A4, A5), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>& Bind<R (A0, A1, A2, A3, A4, A5), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>& Bind<R (A0, A1, A2, A3, A4, A5), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (A0, A1, A2, A3, A4, A5), void>& Bind<R (A0, A1, A2, A3, A4, A5), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::emptyCallback(A0, A1, A2, A3, A4, A5)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14), 
				ArgGetterT<UserTypeT, A15>::Get(userdata, 15));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const void* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const IEventObserverBase* Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (const Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline bool Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>()) // unbind
	{}

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::bind(const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(); // unbind
	}


	// Bind: unbind
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::clear()
	{
		unbind();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::empty() const
	{
		return pHolder->empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14), 
				ArgGetterT<UserTypeT, A15>::Get(userdata, 15));
	}




	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator ! () const
	{
		return empty();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		return R();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const void* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::object() const
	{
		return pHolder->object();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const IEventObserverBase* Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		/* Do nothing */
	}






	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (const Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>& Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator = (Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline bool Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::Bind()
		: pHolder(new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>()) // unbind
	{}

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::Bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& rhs) :
		pHolder(rhs.pHolder)
	{}

	# ifdef YUNI_HAS_CPP_MOVE
	// Move Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::Bind(Bind&& rhs)
	{
		// \important VS may call the other constructor `C&&`...
		pHolder.swap(rhs.pHolder);
	}
	# endif

	// Constructor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		BindType result;
		result.bindFromSymbol(symbol);
		return result;
	}

	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Constructor from a functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::Bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(std::forward<C>(functor));
	}

	# else

	// Constructor: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
	}

	# endif

	// Constructor: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(c, member);
	}




	// Bind: Pointer-to-function
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(pointer);
	}


	// Bind: Pointer-to-function (from a library symbol)
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol)
	{
		if (symbol.valid())
		{
			pHolder = new Private::BindImpl::BoundWithFunction<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(
				reinterpret_cast<FunctionType>(symbol.ptr()));
		}
		else
			unbind();
	}

	// Bind: Pointer-to-function + user data
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		pHolder = new Private::BindImpl::BoundWithFunctionAndUserData
			<typename WithUserData<U>::ParameterType, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>(pointer, userdata);
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	// Bind: functor
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(C&& functor)
	{
		// When moving a bind (instead of copying it), it seems that Visual Studio might call
		// this constructor instead of `Bind&&` (works as expected with gcc and clang)
		if (Static::Type::Equal<C, BindType>::Yes) // moving Bind&& -> Bind&&
		{
			// instanciating the swap method only when the type requires it
			Yuni::Private::BindImpl::MoveConstructor<Static::Type::Equal<C, BindType>::Yes>::SwapBind(pHolder, functor);
		}
		else
			pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(std::forward<C>(functor));
	}
	# endif


	// Bind: pointer-to-member
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(c, member);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			pHolder = new Private::BindImpl::BoundWithMember<C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMember<PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>
				(c, reinterpret_cast<MemberType>(member));
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	// Bind: pointer-to-member const
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C,
		template <class> class OwspP, template <class> class ChckP, class ConvP,
		template <class> class StorP, template <class> class ConsP>
	inline void
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (!(!c))
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP> PtrT;
			pHolder = new Private::BindImpl::BoundWithSmartPtrMemberAndUserData<
				typename WithUserData<U>::ParameterType, PtrT, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(c, member, userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U, class C>
	void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
		typename Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::template WithUserData<U>::ParameterType userdata)
	{
		if (c)
		{
			// The object is not null, go ahead
			// Assigning a new bind
			typedef R (C::*MemberType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);
			pHolder = new Private::BindImpl::BoundWithMemberAndUserData<
				typename WithUserData<U>::ParameterType,C, R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U)>
				(const_cast<C*>(c), reinterpret_cast<MemberType>(member), userdata);
		}
		else
			// The object is null, we should unbind
			unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::bind(const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::unbind()
	{
		pHolder = new Private::BindImpl::None<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(); // unbind
	}


	// Bind: unbind
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::clear()
	{
		unbind();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::empty() const
	{
		return pHolder->empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
	inline R
	Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::callWithArgumentGetter(UserTypeT userdata) const
	{
		(void) userdata;
		return invoke(ArgGetterT<UserTypeT, A0>::Get(userdata, 0), 
				ArgGetterT<UserTypeT, A1>::Get(userdata, 1), ArgGetterT<UserTypeT, A2>::Get(userdata, 2), 
				ArgGetterT<UserTypeT, A3>::Get(userdata, 3), ArgGetterT<UserTypeT, A4>::Get(userdata, 4), 
				ArgGetterT<UserTypeT, A5>::Get(userdata, 5), ArgGetterT<UserTypeT, A6>::Get(userdata, 6), 
				ArgGetterT<UserTypeT, A7>::Get(userdata, 7), ArgGetterT<UserTypeT, A8>::Get(userdata, 8), 
				ArgGetterT<UserTypeT, A9>::Get(userdata, 9), ArgGetterT<UserTypeT, A10>::Get(userdata, 10), 
				ArgGetterT<UserTypeT, A11>::Get(userdata, 11), ArgGetterT<UserTypeT, A12>::Get(userdata, 12), 
				ArgGetterT<UserTypeT, A13>::Get(userdata, 13), ArgGetterT<UserTypeT, A14>::Get(userdata, 14), 
				ArgGetterT<UserTypeT, A15>::Get(userdata, 15));
	}




	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator ! () const
	{
		return empty();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const
	{
		return pHolder->invoke(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline R Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		return R();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const void* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::object() const
	{
		return pHolder->object();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline const IEventObserverBase* Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::observerBaseObject() const
	{
		return pHolder->observerBaseObject();
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::isDescendantOf(const IEventObserverBase* obj) const
	{
		return pHolder->isDescendantOf(obj);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::isDescendantOfIEventObserverBase() const
	{
		return pHolder->isDescendantOfIEventObserverBase();
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::print(std::ostream& out) const
	{
		return pHolder->print(out);
	}



	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline void Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)
	{
		/* Do nothing */
	}






	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15))
	{
		bind(pointer);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator = (const Yuni::DynamicLibrary::Symbol& symbol)
	{
		bind(symbol);
		return *this;
	}


	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator = (const Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& rhs)
	{
		// Inc the reference count
		pHolder = rhs.pHolder;
		return *this;
	}


	# ifdef YUNI_HAS_CPP_BIND_LAMBDA
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class C>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator = (C&& functor)
	{
		// Inc the reference count
		pHolder = new Private::BindImpl::BoundWithFunctor<C, R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>(std::forward<C>(functor));
		return *this;
	}
	# endif


	# ifdef YUNI_HAS_CPP_MOVE
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>& Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator = (Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>&& rhs)
	{
		pHolder.swap(rhs.pHolder);
		return *this;
	}
	# endif

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const
	{
		return pHolder->compareWithPointerToFunction(pointer);
	}

	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	template<class U>
	inline bool Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT>::operator == (const U* object) const
	{
		return pHolder->compareWithPointerToObject(static_cast<const void*>(object));
	}






} // namespace Yuni
