/*
** YUNI's default license is the GNU Lesser Public License (LGPL), with some
** exclusions (see below). This basically means that you can get the full source
** code for nothing, so long as you adhere to a few rules.
**
** Under the LGPL you may use YUNI for any purpose you wish, and modify it if you
** require, as long as you:
**
** Pass on the (modified) YUNI source code with your software, with original
** copyrights intact :
**  * If you distribute electronically, the source can be a separate download
**    (either from your own site if you modified YUNI, or to the official YUNI
**    website if you used an unmodified version) â€“ just include a link in your
**    documentation
**  * If you distribute physical media, the YUNI source that you used to build
**    your application should be included on that media
** Make it clear where you have customised it.
**
** In addition to the LGPL license text, the following exceptions / clarifications
** to the LGPL conditions apply to YUNI:
**
**  * Making modifications to YUNI configuration files, build scripts and
**    configuration headers such as yuni/platform.h in order to create a
**    customised build setup of YUNI with the otherwise unmodified source code,
**    does not constitute a derived work
**  * Building against YUNI headers which have inlined code does not constitute a
**    derived work
**  * Code which subclasses YUNI classes outside of the YUNI libraries does not
**    form a derived work
**  * Statically linking the YUNI libraries into a user application does not make
**    the user application a derived work.
**  * Using source code obsfucation on the YUNI source code when distributing it
**    is not permitted.
** As per the terms of the LGPL, a "derived work" is one for which you have to
** distribute source code for, so when the clauses above define something as not
** a derived work, it means you don't have to distribute source code for it.
** However, the original YUNI source code with all modifications must always be
** made available.
*/
#pragma once
#include "../../yuni.h"
#include "../../thread/policy.h"
#include "../static/types.h"
#include "../static/assert.h"
#include "../static/remove.h"
#include "../smartptr.h"
#include "traits.h"
#include "../dynamiclibrary/symbol.h"
#include "fwd.h"



/*!
** \internal This file is automatically generated by 'bind.h.generator.hpp'.
** Please make any modifications you wish to this script instead of
** this file, as they will otherwise be lost at the next generation.
*/


namespace Yuni
{

	/*!
	** \brief A delegate implementation
	** \ingroup Events
	**
	** How to bind a mere function :
	** \code
	** #include <iostream>
	** #include <yuni/bind.h>
	**
	** static int Foo(int value)
	** {
	**	std::cout << "Foo: " << value << std::endl;
	**	return 0;
	** }
	**
	** int main()
	** {
	**	Yuni::Bind<int (int)> callback;
	**	callback.bind(&Foo);
	**	callback(42);
	**	callback(61);
	**	callback(-1)
	**	return 0;
	** }
	** \endcode
	**
	** How to bind a member of an object :
	** \code
	** #include <iostream>
	** #include <yuni/bind.h>
	**
	** class Foo
	** {
	** public:
	**	int bar(int value)
	**	{
	**		std::cout << "Foo::bar  : " << value << std::endl;
	**		return 0;
	**	}
	**	int bar2(int value)
	**	{
	**		std::cout << "Foo::bar2 : " << value << std::endl;
	**		return 0;
	**	}
	** };
	**
	** int main()
	** {
	**	Foo foo;
	**	Yuni::Bind<int (int)> callback;
	**	callback.bind(foo, &Foo::bar);
	**	callback(42);
	**	callback(61);
	**	callback(-1)
	**	callback.bind(foo, &Foo::bar2);
	**	callback(42);
	**	callback(61);
	**	callback(-1)
	**	return 0;
	** }
	** \endcode
	**
	** This class is thread-safe, this is guaranteed by the use of smartptr.
	**
	** \note This class does not take care of deleted objects. It is the responsibility
	** of the user to unbind the delegate before the linked object is delete and/or
	** to not invoke the delegate when the object does not exist.
	**
	** \note It is safe to provide a null pointer when binding the delegate
	** \note It is always safe to invoke the delegate when unbound.
	**
	** \tparam P The prototype of the targetted function/member
	*/
	template<class P = void (), class Dummy = void>
	class YUNI_DECL Bind;










	//
	// --- Specializations for Bind<> ---
	//




	/*
	** \brief Bind to a function/member with 0 argument (Specialization)
	*/
	template<class R>
	class YUNI_DECL Bind<R (), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (), void> Type;
		//! The Bind Type
		typedef Bind<R (), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)();
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)();
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)() const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 0,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 0 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)());

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)());
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)());

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)());

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)());
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)() const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)() const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke() const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () () const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)());
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)()) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback();
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid();

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R()> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R()>






	/*
	** \brief Bind to a function/member with 0 argument (Specialization)
	*/
	template<class R>
	class YUNI_DECL Bind<R (*)(), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)();
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)();
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)() const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 0,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 0 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)());

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)());
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)());

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)());

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)());
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)() const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)() const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke() const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () () const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)());
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)()) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback();
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid();

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R()> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R()>






	/*
	** \brief Bind to a function/member with 0 argument (Specialization)
	*/
	template<class ClassT, class R>
	class YUNI_DECL Bind<R (ClassT::*)(), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)();
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)();
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)() const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 0,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 0 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)());

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)());
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)());

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)());

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)());
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)() const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)() const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke() const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () () const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)());
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)()) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback();
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid();

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R()> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R()>






	/*
	** \brief Bind to a function/member with 1 argument (Specialization)
	*/
	template<class R, class A0>
	class YUNI_DECL Bind<R (A0), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0), void> Type;
		//! The Bind Type
		typedef Bind<R (A0), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 1,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 1 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0)>






	/*
	** \brief Bind to a function/member with 1 argument (Specialization)
	*/
	template<class R, class A0>
	class YUNI_DECL Bind<R (*)(A0), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 1,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 1 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0)>






	/*
	** \brief Bind to a function/member with 1 argument (Specialization)
	*/
	template<class ClassT, class R, class A0>
	class YUNI_DECL Bind<R (ClassT::*)(A0), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 1,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 1 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0)>






	/*
	** \brief Bind to a function/member with 2 arguments (Specialization)
	*/
	template<class R, class A0, class A1>
	class YUNI_DECL Bind<R (A0, A1), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 2,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 2 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1)>






	/*
	** \brief Bind to a function/member with 2 arguments (Specialization)
	*/
	template<class R, class A0, class A1>
	class YUNI_DECL Bind<R (*)(A0, A1), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 2,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 2 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1)>






	/*
	** \brief Bind to a function/member with 2 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 2,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 2 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1)>






	/*
	** \brief Bind to a function/member with 3 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2>
	class YUNI_DECL Bind<R (A0, A1, A2), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 3,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 3 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2)>






	/*
	** \brief Bind to a function/member with 3 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2>
	class YUNI_DECL Bind<R (*)(A0, A1, A2), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 3,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 3 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2)>






	/*
	** \brief Bind to a function/member with 3 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 3,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 3 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2)>






	/*
	** \brief Bind to a function/member with 4 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3>
	class YUNI_DECL Bind<R (A0, A1, A2, A3), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 4,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 4 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3)>






	/*
	** \brief Bind to a function/member with 4 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 4,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 4 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3)>






	/*
	** \brief Bind to a function/member with 4 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 4,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 4 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3)>






	/*
	** \brief Bind to a function/member with 5 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 5,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 5 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4)>






	/*
	** \brief Bind to a function/member with 5 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 5,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 5 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4)>






	/*
	** \brief Bind to a function/member with 5 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 5,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 5 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4)>






	/*
	** \brief Bind to a function/member with 6 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 6,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 6 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5)>






	/*
	** \brief Bind to a function/member with 6 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 6,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 6 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5)>






	/*
	** \brief Bind to a function/member with 6 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 6,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 6 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5)>






	/*
	** \brief Bind to a function/member with 7 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 7,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 7 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6)>






	/*
	** \brief Bind to a function/member with 7 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 7,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 7 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6)>






	/*
	** \brief Bind to a function/member with 7 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 7,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 7 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6)>






	/*
	** \brief Bind to a function/member with 8 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 8,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 8 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7)>






	/*
	** \brief Bind to a function/member with 8 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 8,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 8 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7)>






	/*
	** \brief Bind to a function/member with 8 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 8,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 8 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7)>






	/*
	** \brief Bind to a function/member with 9 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 9,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 9 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>






	/*
	** \brief Bind to a function/member with 9 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 9,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 9 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>






	/*
	** \brief Bind to a function/member with 9 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 9,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 9 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8)>






	/*
	** \brief Bind to a function/member with 10 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 10,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 10 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>






	/*
	** \brief Bind to a function/member with 10 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 10,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 10 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>






	/*
	** \brief Bind to a function/member with 10 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 10,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 10 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9)>






	/*
	** \brief Bind to a function/member with 11 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 11,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 11 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>






	/*
	** \brief Bind to a function/member with 11 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 11,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 11 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>






	/*
	** \brief Bind to a function/member with 11 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 11,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 11 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)>






	/*
	** \brief Bind to a function/member with 12 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 12,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 12 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>






	/*
	** \brief Bind to a function/member with 12 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 12,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 12 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>






	/*
	** \brief Bind to a function/member with 12 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 12,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 12 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11)>






	/*
	** \brief Bind to a function/member with 13 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 13,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 13 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>






	/*
	** \brief Bind to a function/member with 13 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 13,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 13 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>






	/*
	** \brief Bind to a function/member with 13 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 13,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 13 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12)>






	/*
	** \brief Bind to a function/member with 14 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 14,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 14 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>






	/*
	** \brief Bind to a function/member with 14 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 14,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 14 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>






	/*
	** \brief Bind to a function/member with 14 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 14,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 14 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13)>






	/*
	** \brief Bind to a function/member with 15 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 15,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 15 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>






	/*
	** \brief Bind to a function/member with 15 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 15,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 15 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>






	/*
	** \brief Bind to a function/member with 15 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 15,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 15 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14)>






	/*
	** \brief Bind to a function/member with 16 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	class YUNI_DECL Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> Type;
		//! The Bind Type
		typedef Bind<R (A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 16,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 16 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>






	/*
	** \brief Bind to a function/member with 16 arguments (Specialization)
	*/
	template<class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	class YUNI_DECL Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> Type;
		//! The Bind Type
		typedef Bind<R (*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), void> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 16,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 16 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>






	/*
	** \brief Bind to a function/member with 16 arguments (Specialization)
	*/
	template<class ClassT, class R, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
	class YUNI_DECL Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT> final
	{
	public:
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT> Type;
		//! The Bind Type
		typedef Bind<R (ClassT::*)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), ClassT> BindType;

		//! The most suitable smartptr for the class
		typedef SmartPtr<BindType> Ptr;

		//! Pointer-to-function
		typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! The type of the return value
		typedef R ReturnType;

		/*!
		** \brief Pointer-to-member of any Class
		** \tparam C Any class
		*/
		template<class C>
		struct PointerToMember final
		{
			//! Mere type for C
			typedef typename Static::Remove::All<C>::Type Class;
			//! Type for a pointer-to-member
			typedef R (Class::*Type)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
			//! Type for a const pointer-to-member
			typedef R (Class::*ConstType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
		};
		enum
		{
			//! The number of arguments
			argumentCount = 16,
		};
		enum
		{
			//! A non-zero value if the prototype has a return value (!= void)
			hasReturnValue = Static::Type::StrictlyEqual<R,void>::No,
		};

		/*!
		** \brief Type of each argument by their index
		**
		** The typedef Type is always valid, even if the argument does not exist.
		** If this case, the type will be the empty class Yuni::None. You may
		** use `argumentCount` to know exactly the number of arguments.
		** \tparam I Index of the argument (zero-based)
		*/
		template<int I>
		struct Argument final
		{
			//! Type of the argument at position I (zero-based)
			typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15),I>::Type Type;
		};

		/*!
		** \brief Types when an additional user data is present
		** \tparam U Type for the additional user data
		*/
		template<class U>
		struct WithUserData final
		{
			//! The most suitable type as a parameter
			typedef typename Private::BindImpl::Parameter<U>::Type ParameterType;

			enum
			{
				//! The number of arguments
				argumentCount = 16 + 1, // original count + userdata
			};
			//! A pointer-to-function
			typedef R (*FunctionType)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U);

			/*!
			** \brief Type of each argument by their index
			**
			** The typedef Type is always valid, even if the argument does not exist.
			** If this case, the type will be the empty class Yuni::None. You may
			** use `argumentCount` to know exactly the number of arguments.
			** \tparam I Index of the argument (zero-based)
			*/
			template<int I>
			struct Argument final
			{
				//! Type of the argument at position I
				typedef typename Private::BindImpl::Argument<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),I>::Type Type;
			};
		}; // class WithUserData


	public:
		/*!
		** \brief Instanciate a Yuni::Bind from an exported symbol from a dynamic library
		** \param symbol A symbol from a shared library
		** \return A new bind
		*/
		static BindType FromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);


	public:
		//! \name Constructor & Destructor
		//@{
		//! Default Constructor
		Bind();

		//! Copy constructor
		Bind(const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Move constructor
		Bind(Bind&& rhs);
		# endif

		/*!
		** \brief Constructor, from a pointer-to-method
		**
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> Bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Constructor from a functor, most likely a lambda
		** \param functor A functor
		*/
		template<class C> Bind(C&& functor);
		# else
		/*!
		** \brief Constructor from a pointer-to-function
		** \param pointer A pointer-to-function
		*/
		Bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		# endif
		//@}


		//! \name Bind
		//@{
		/*!
		** \brief Bind to a function
		**
		** \param pointer A pointer-to-function
		*/
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to a function with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \param pointer  A pointer-to-function
		** \param userdata The userdata that will be copied and stored
		*/
		template<class U>
		void bind(R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));

		/*!
		** \brief Bind to an object member
		**
		** \tparam C Any smartptr
		** \param c A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		template<class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to a const object member
		**
		** \tparam C Any class
		** \param c      A pointer to an object (can be null)
		** \param member A pointer-to-member
		*/
		template<class C> void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam U The type of the user data
		** \tparam C Any class
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C>
		void bind(C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U), typename WithUserData<U>::ParameterType userdata);
		template<class U, class C>
		void bind(const C* c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const, typename WithUserData<U>::ParameterType userdata);

		/*!
		** \brief Bind to an object member with a custom and persistent user data
		**
		** \tparam C Any smartptr
		** \param c        A pointer to an object (can be null)
		** \param member   A pointer-to-member
		** \param userdata User data
		*/
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U),
			typename WithUserData<U>::ParameterType userdata);
		template<class U, class C,
			template <class> class OwspP, template <class> class ChckP, class ConvP,
			template <class> class StorP, template <class> class ConsP>
		void bind(const SmartPtr<C, OwspP,ChckP,ConvP,StorP,ConsP>& c, R (C::*member)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15, U) const,
			typename WithUserData<U>::ParameterType userdata);


		/*!
		** \brief Bind from another Bind object
		*/
		void bind(const Bind& rhs);

		/*!
		** \brief Bind from a library symbol
		**
		** \param symbol A symbol from a dynamic library
		*/
		void bindFromSymbol(const Yuni::DynamicLibrary::Symbol& symbol);

		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		/*!
		** \brief Bind from a functor, most likely a lambda
		*/
		template<class C> void bind(C&& functor);
		# endif

		//@} // Bind


		//! \name Unbind
		//@{
		/*!
		** \brief Unbind
		**
		** It is safe to call this method several times
		*/
		void unbind();

		//! \see unbind
		void clear();

		//! Get if the object is binded
		bool empty() const;
		//@}


		//! \name Invoke
		//@{
		/*!
		** \brief Invoke the delegate
		**
		** The operator () can be used instead.
		*/
		R invoke(A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;

		/*!
		** \brief Invoke the bind using a getter for the arguments.
		**
		** Nothing will happen if the pointer is null
		** However, the returned value may not be what we shall expect
		** (the default constructor of the returned type is used in this case).
		**
		** \param userdata  Some user data
		*/
		template<class UserTypeT, template<class UserTypeGT, class ArgumentIndexTypeT> class ArgGetterT>
		R callWithArgumentGetter(UserTypeT userdata) const;
		//@}


		//! \name Print
		//@{
		/*!
		** \brief Print the value to the std::ostream
		**
		** \param out A stream used to write output
		*/
		void print(std::ostream& out) const;
		//@}


		//! \name Inheritance
		//@{
		/*!
		** \brief Get the raw pointer to the binded object (if any)
		**
		** If bound to a class, the return value will never be null. There is no way
		** to know statically the type of the object.
		** \warning It is the responsability to the user to use this method with care
		**
		** \return A non-null pointer if bound to a class
		*/
		const void* object() const;

		//! Get if the attached class is a descendant of 'IEventObserverBase'
		bool isDescendantOfIEventObserverBase() const;
		//! Get if the attached class is a real descendant of 'IEventObserverBase'
		bool isDescendantOf(const IEventObserverBase* obj) const;

		/*!
		** \brief Get the pointer to the binded object (if any) cast into IEventObserverBase
		**
		** \warning This method should never be used by the user
		** \return A non-null pointer if bound to a class
		*/
		const IEventObserverBase* observerBaseObject() const;
		//@}


		//! \name Operators
		//@{
		//! Get if the object is binded
		bool operator ! () const;
		/*!
		** \brief Invoke the delegate
		** \see invoke()
		*/
		R operator () (A0 a0, A1 a1, A2 a2, A3 a3, A4 a4, A5 a5, A6 a6, A7 a7, A8 a8, A9 a9, A10 a10, A11 a11, A12 a12, A13 a13, A14 a14, A15 a15) const;
		//! Assignment with another Bind object
		Bind& operator = (const Bind& rhs);
		# ifdef YUNI_HAS_CPP_MOVE
		//! Assignment move
		Bind& operator = (Bind&& symbol);
		# endif
		//! Assignment with a pointer-to-function
		Bind& operator = (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15));
		//! Assignment with a library symbol
		Bind& operator = (const Yuni::DynamicLibrary::Symbol& symbol);
		# ifdef YUNI_HAS_CPP_BIND_LAMBDA
		//! Assignment from a functor, most likely a lambda
		template<class C> Bind& operator = (C&& functor);
		# endif

		//! Comparison with a pointer-to-function
		bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)) const;
		//! Comparison with a pointer-to-object
		template<class U> bool operator == (const U* object) const;
		//@}

	private:
		//! Empty callback when not binded (returns a default value)
		R emptyCallback(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
		//! Empty callback when not binded (returns void)
		void emptyCallbackReturnsVoid(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);

	private:
		//! The holder type
		typedef Private::BindImpl::IPointer<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)> IHolder;

		/*!
		** \brief Pointer to function/member
		** \internal The smartptr is used to guarantee the thread-safety, and to avoid
		** expensive copies
		*/
		SmartPtr<IHolder> pHolder;

		template<bool> friend struct Yuni::Private::BindImpl::MoveConstructor;

	}; // class Bind<R(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15)>












} // namespace Yuni

#include "bind.hxx"





template<class P, class DummyT>
inline std::ostream& operator << (std::ostream& out, const Yuni::Bind<P,DummyT>& rhs)
{
	rhs.print(out);
	return out;
}


// Comparison with any pointer-to-object
template<class U, class P, class DummyT>
inline bool operator == (const U* object, const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == object);
}

// Comparison with any pointer-to-object
template<class U, class P, class DummyT>
inline bool operator != (const U* object, const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != object);
}



template<class R, class P, class DummyT>
inline bool operator == (R (*pointer)(), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT>
inline bool operator != (R (*pointer)(), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0>
inline bool operator == (R (*pointer)(A0), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0>
inline bool operator != (R (*pointer)(A0), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1>
inline bool operator == (R (*pointer)(A0, A1), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1>
inline bool operator != (R (*pointer)(A0, A1), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2>
inline bool operator == (R (*pointer)(A0, A1, A2), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2>
inline bool operator != (R (*pointer)(A0, A1, A2), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3>
inline bool operator == (R (*pointer)(A0, A1, A2, A3), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3>
inline bool operator != (R (*pointer)(A0, A1, A2, A3), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
inline bool operator == (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind == pointer);
}

template<class R, class P, class DummyT, class A0, class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11, class A12, class A13, class A14, class A15>
inline bool operator != (R (*pointer)(A0, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15), const Yuni::Bind<P,DummyT>& bind)
{
	return (bind != pointer);
}



